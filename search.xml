<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[NodeJs]]></title>
      <url>%2F2017%2F02%2F08%2Fnode.js%2F</url>
      <content type="text"><![CDATA[一、Node.js的介绍简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 我们可以使用以下命令来查看当前的 Node 版本： 12345678910$ node -vv4.4.3第一个Node.js程序：Hello World！以下是我们的第一个Node.js程序：实例console.log("Hello World");打开cmd，到文件的目录下通过node命令来执：node helloworld.js 如果是在webstorm中运行，直接右键run就可以运行了，也可以在左下角下面有一个Terminal,打开后也就是打开cmd一样的，也可以输入命令运行。 二、node的http模块模块:把各种功能划分在模块中,通过模块编写相关代码http模块:负责web服务器相关任务的模块 1234567891011121314151617181920212223242526// 1、引入http模块var http = require(&apos;http&apos;);// 2、创建服务// 当服务受到客户端发来的http请求时,执行回调函数var server = http.createServer(function (req, res) &#123;/** req参数:请求对象,从客户端发到服务器中的请求信息存放在这个对象中* res参数:响应对象,需要返回给客户端的信息要放在这个对象中**/console.log(req.url);console.log(req.method);res.setHeader(&apos;content-type&apos;, &apos;text/html;charset=utf-8;&apos;)//index.html:welcome to index;//login.html:please input your user and passif (req.url == &apos;/index.html&apos; || req.url == &apos;/&apos;) &#123; res.write(&apos;welcome to index&apos;);&#125; else if (req.url == &apos;/login.html&apos;) &#123; res.write(&apos;please input your user and pass&apos;);&#125; else &#123; res.write(&apos;404, not found&apos;);&#125; res.end();&#125;);// 3、让服务监听某个端口server.listen(&apos;8888&apos;); 三、node的文件操作fs:专门负责所有的文件、目录操作的模块 12345678910111213141516171819202122232425262728293031323334353637var fs = require(&apos;fs&apos;);// 读取文件/** readFile():异步读取文件的方法。* readFile()的三个参数* 第一个参数:要读取的文件路径* 第二个参数:文件的编码格式* 第三个参数:读取成功后的回调函数,该函数两个参数:第一个是读取失败时* 的失败信息,第二个表示读取成功后的文件内容**/ fs.readFile(&apos;./demo.txt&apos;, &apos;utf-8&apos;,function (err, data) &#123;if (!err) &#123; console.log(data);&#125;&#125;);var data = fs.readFileSync(&apos;./demo.txt&apos;);console.log(data.toString());//写入文件操作// a表示拼接的形式写入新内容,w以覆盖的形式写入新内容fs.writeFile(&apos;./hello.txt&apos;,&apos;一只乌鸦口渴了&apos;,&#123;flag: &apos;a&apos;&#125;, function (err) &#123;if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;写入成功&apos;); &#125;&#125;);fs.writeFileSync(&apos;./hello.txt&apos;,&apos;hello world&apos;,&#123;flag:&apos;w&apos;&#125;);利用node的文件读写操作,实现复制文件的功能1、同步读取demo.txt文件中的数据var data = fs.readFileSync(&apos;./demo.txt&apos;,&apos;utf-8&apos;);2、把读取出来的输入写到另一个新文件中fs.writeFileSync(&apos;./demo副本.txt&apos;, data, &#123;flag:&apos;w&apos;&#125;);fs.writeFileSync(&apos;./1副本.gif&apos;,fs.readFileSync(&apos;./1.gif&apos;),&#123;flag:&apos;w&apos;&#125;); 四、文件操作stream读写文件stream: 读写是分块读写,把一个文件切分为若干块,分别读写着若干块文 件,大大减轻服务器对内存的要求 123456789101112131415var fs = require(&apos;fs&apos;);// 创建文件读取流var rs = fs.createReadStream(&apos;./1.gif&apos;);// 创建文件写入流var ws = fs.createWriteStream(&apos;./2.gif&apos;);// 读取流在读取文件时,每次读64k的数据,每读64k,就会触发rs下的data事件,可以给这个事件绑定函数,通过函数参数获取到读取的数据 rs.on(&apos;data&apos;, function (chunk) &#123; // 调用写入流ws的write方法,把每次读出的64k数据写进指定的文件中 // write方法的回调函数:当写入结束时,会触发执行 ws.write(chunk,function () &#123; console.log(&apos;写入完毕&apos;); &#125;);&#125;);//pipe():是读取流的方法,参数是要把数据写入的目的地(一般是写入流)。该方法会控制读取流的读取速度:每读64k数据后,交给写入流写入,当数据写入到磁盘后,再进行下一次读取。 rs.pipe(ws); 五、文件操作之目录操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var fs = require(&apos;fs&apos;);// fs.mkdir():创建一个新路径// 第二个参数:mode,由四位数字组成:// 第一位固定写法:0;第二位:表示管理员权限;第三位:表示:组用户权限;第四位:表示其他用户权限。// 1:表示可执行// 2:表示可写// 4:表示可读// 我们通过叠加以上权限的数组,能够灵活设置文件夹的权限fs.mkdir(&apos;./directory&apos;, 0777, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;创建成功&apos;); &#125;&#125;);// 判断目录是否已经存在// fs.exists():两个参数,第一个参数:表示要判断的目录路径;第二个参数:表示判断结果的回调函数,该函数有一个布尔的参数,用来标示该目录是否存在fs.exists(&apos;./directory&apos;, function (bol) &#123; console.log(bol);&#125;);// 查看文件或目录的详情fs.stat(&apos;./directory&apos;, function (err, stats) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(stats); &#125;&#125;)// 把文件或目录由相对路径转换为绝对路径fs.realpath(&apos;./1.gif&apos;,function (err, path) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(path); &#125;&#125;)// 给文件重命名fs.rename(&apos;./demo.txt&apos;,&apos;./newDemo.txt&apos;, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;改名成功&apos;); &#125;&#125;); 六、http.js12345678910111213141516171819202122var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);var url = require(&apos;url&apos;);var server = http.createServer(function (req, res) &#123;var urlStr = req.url;// 参数放true,可以把请求参数转换为对象模式 //pathname是接口 //query是指请求参数var urlObj = url.parse(urlStr,true);if (urlObj.pathname == &apos;/&apos;) &#123; var rs = fs.createReadStream(&apos;./login.html&apos;); rs.pipe(res);&#125; else if (urlObj.pathname == &apos;/msg&apos;) &#123; console.log(urlObj.query); if (urlObj.query.user == &apos;admin&apos; &amp;&amp; urlObj.query.pass == &apos;123&apos;) &#123; res.write(&apos;&#123;err:1,msg:&quot;成功&quot;&#125;&apos;);//请求链接一直没有 断开 res.end(); &#125;&#125;&#125;);server.listen(&apos;8888&apos;); 七、http模块接受get请求数据1234567891011121314151617181920var http = require(&quot;http&quot;); var fs = require(&quot;fs&quot;); var url = require(&quot;url&quot;);//专门用来处理url的 var server = http.createServer(function (req,res) &#123; res.setHeader(&apos;content-type&apos;, &quot;text/html;charset=utf-8;&quot;); var urlstr = req.url; var urlobj =url.parse(urlstr,true);//为了分离接口和参数，把url转换成对象 if(urlobj.pathname ==&apos;./login.html&apos;||urlobj.pathname ==&quot;/&quot;)&#123; var rs = fs.createReadStream(&apos;./login.html&apos;); rs.pipe(res); &#125;else if(urlobj.pathname == &quot;/login&quot;)&#123; if(urlobj.query.user==&apos;wlj&apos;&amp;&amp;urlobj.query.pass==&apos;123&apos;)&#123; res.end(&apos;&#123;&quot;err&quot;:1,&quot;msg&quot;:&quot;登录成功&quot;&#125;&apos;); &#125;else&#123; res.end(&apos;&#123;&quot;err&quot;:0,&quot;msg&quot;:&quot;登录失败&quot;&#125;&apos;); &#125; &#125;&#125;); server.listen(8100, function () &#123; console.log(&quot;服务器已经启动&quot;); 八、http模块接受post请求数据12345678910111213141516171819202122232425262728293031var http = require(&quot;http&quot;);var fs = require(&quot;fs&quot;);var url = require(&quot;url&quot;);//专门用来处理url的,上面三个框架是系统自带的var qs = require(&quot;querystring&quot;);//自己引入框架就是在工程目录下用npm install querystring;//自己引入的一个框架，可以把post请求获取的字符串参数转换为对象//把前端不同的请求，发送不同的页面，叫做路由var server = http.createServer(function (req,res) &#123; res.setHeader(&apos;content-type&apos;, &quot;text/html;charset=utf-8;&quot;); var urlobj = url.parse(req.url,true); if(urlobj.pathname ==&apos;./login.html&apos;||urlobj.pathname ==&quot;/&quot;)&#123; var rs = fs.createReadStream(&apos;./login.html&apos;); rs.pipe(res); &#125;else if(urlobj.pathname == &quot;/login&quot;)&#123; req.on(&quot;data&quot;, function (chunk) &#123; //req本身是一个读取流，res是一个写入流 var str = chunk.toString(); var obj = qs.parse(str); //console.log(obj); if(obj.user == &quot;wlj&quot;&amp;&amp;obj.pass == &quot;123&quot;)&#123; res.end(&apos;&#123;&quot;err&quot;:1,&quot;msg&quot;:&quot;success&quot;&#125;&apos;) &#125;else&#123; res.end(&apos;&#123;&quot;err&quot;:0,&quot;msg&quot;:&quot;err&quot;&#125;&apos;) &#125; &#125;) &#125;&#125;); server.listen(8200, function () &#123; console.log(&quot;服务器已经启动&quot;);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新浪云+微信JSSDK]]></title>
      <url>%2F2016%2F12%2F08%2F%E6%96%B0%E6%B5%AA%E4%BA%91%2B%E5%BE%AE%E4%BF%A1JSSDK%2F</url>
      <content type="text"><![CDATA[一、新浪云1.登录新浪云 如果有微博账号的可以直接用微博账号登录即可 2.点击云应用SAE 3.点击进入控制台 4.点击创建新应用 5.设置部署环境(二级域名可以自己随意添加) 6.获得Git仓库信息还有部署说明 7.打开本地文件夹使用git命令然后使用git信息把该文件夹部署到新浪云中12345(1)git init 配置git环境(2)git add . 把文件加入到缓存区(3)git commit -m "注释"(4)$ git remote add sae https://git.sinacloud.com/biga(5)$ git push sae master:1 8.只需在新浪云页面刷新一下页面 9.点击链接注意：当一个后台应用服务器访问的时候默认都是优先找index开头的文件，所以可能进去是直接在根目录下面是访问不到的但是可以自己手动添加路径 10.可以使用二维码生成器，制作二维码 二、微信公众号微信JSSDK是什么？以及使用流程？ 如果项目需要使用微信提供的一些功能，例如：分享、定位、扫一扫、支付、等，就需要借助微信JSSDK来实现这些功能 使用流程：1.将自己项目的域名添加到微信公众账号中，设置为安全域名2.在代码中引入JSSDK所需的js文件3.进行配置: wx.config({debug: true, appId: ‘’, timestamp: ‘’, nonceStr: ‘’, signature: ‘’, jsApiList: []});4.调用JSSDK提供的方法进行调用 （一）先注册一个微信公众号1.打开微信公众平台2.点击立即注册 3.点击订阅号4.然后填写信息，在选择类型的时候，选择个人 （二）微信JS-SDK1.点击开发者工具2.点击进入开发者文档 3.点击微信网页开发 4.点击微信JS-SDK说明文档 然后回到主页面点击公众号设置 点击功能设置进入JS接口安全域名 然后到新浪云中把刚刚得到的那个链接粘贴过来放到域名X中，然后点击下载MP文件再放到我们上传到新浪云的文件中，然后再重新进行一遍上传操作 又回到JS-SDK说明文档的页面，看起来会觉得特别繁琐，但是没关系，我们可以直接翻到最后面，就会看到一个实例代码，然后进行下载 然后打开文档，会看到php文件，因为一开始我们选择的就是php服务端，然后里面还会有一个sample.php的文件，里面就是示例代码了，已经帮我们写好了 在上传到新浪云的文件中打开index.html,比如想要实现点击选取照片按钮，就会访问到相册的功能，就是绑定click事件，函数名就是openWeiixn 然后把之前下载的php文件中的四个粘贴过来到本地新浪云的文件中把里面的sample.php名字改为weixin.php,因为上面的事件函数就是openWeiixn的函数里面的链接到weixin.php然后把AppID和AppSecret换成我们的密钥信息 密钥需要显示，自己安全验证 把自己想要的功能接口粘贴到jsApiList 然后在接口内容粘贴过来到wx.ready的函数中 最后就可以预览了，如果报错可以查看文档 把最后的特殊问题复制到我们刚刚的weixin.php文件中]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3新属性和动画]]></title>
      <url>%2F2016%2F10%2F18%2Fcss3%E6%96%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[一、背景和边框1.border-radius: 110px 20px 30px 40px /50px 60px 70px 80px; 2.box-shadow: x y blur color;inset / outset 设置内外阴影语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 第一个数值是水平方向的阴影方向，正的是右侧，左侧是负值，第一个表示的垂直方向的正的表示在下边，上面为负值前面的值表示的是投影的像素，第三个值表示的是阴影的范围 1234567box-shadow: 8px 8px 24px red; /*设置里面的阴影inset，默认的是outset外部的*/ /*border:1px solid red;*/ /*box-shadow: 8px 8px 24px gray, 5px 5px 10px gray, 10px 10px 15px gray;*/ /*如果想要改变阴影的浓度*/ 3.background-size 设置背景图片的尺寸，只有一个值表示图片的宽度设置为指定的值，为了保证缩放后的图片不变形，高度会缩放对应的尺寸。有两个值时，第一个值设置的是图片的宽度，第二个值设置的是图片的高度。 12background-image: url(zhangyixing.jpg);background-size: 100%; 4.background-origin 设置图片展示的起始位置，可以从边框、内边距、content的左上角开始渲染图片。从渲染起始位置开始展示图片，一直到图片展示结束位置位置，如果没有关闭平铺，则空白位置平铺填满，如果关闭了平铺，则空白保留。 padding-box 默认 ，border-box 12background-image:url(img/cdb6c8a19d60.jpg);background-origin: content-box; 5.background-clip 背景的裁剪border-box | padding-box | content-box 1234background-image:url(img/cdbba61e4660.jpg);background-clip: content-box;background-origin: content-box;background-size: 100%; 6.颜色渐变(1) 线性渐变 ： 123background: linear-gradient(to right, red, green, blue); background: linear-gradient(45deg, red, blue);background: linear-gradient(180deg, blue, white); (2) 径向渐变 ：background: radial-gradient(aqua, blue);background: radial-gradient(circle, aqua, blue);background: radial-gradient(100px 20px, aqua, blue); 1background: radial-gradient(100px 10px, green, yellow); 二、文本效果text-shadow x, y, blur, color blur 和 color 是可选word-wrap英文单词换行 normal | break-word 强制换行 123456789101112131415p.test1 &#123; white-space: nowrap; width: 200px; border: 1px solid #000000; overflow: hidden; text-overflow: clip; &#125; p.test2 &#123; white-space: nowrap; width: 200px; border: 1px solid #000000; overflow: hidden; text-overflow: ellipsis; &#125; 三、动画(1) 过渡动画：transitioncss3过渡是元素从一种样式逐渐改变为另一种的效果有两个必须的内容： 1、指定要添加的效果的css属性2、指定效果的持续时间 12345678910div&#123; transition: width 2s; -webkit-transition: width 2s; &#125;div:hover&#123; width:300px;&#125; 如果要添加多个样式的变换效果，添加的属性由逗号分隔 12345div&#123; transition: width 2s, height 2s, transform 2s; -webkit-transition: width 2s, height 2s, -webkit-transform 2s;&#125; transition-property:规定应用过渡的css属性的名称，可以设置all表示所有的改变属性都可以过渡 transition-duration:定义过渡效果花费的时间，默认是0 transition-timing-function:规定过渡效果的时间曲线，默认是”ease” transition-delay:规定过渡效果何时开始，默认是0，过渡的延迟时间 123456789101112div&#123; transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; /* Safari */ -webkit-transition-property:width; -webkit-transition-duration:1s; -webkit-transition-timing-function:linear; -webkit-transition-delay:2s;&#125; 对于浏览器兼容问题，只要写一个原本的，还写一个webkit适配就可以了，因为现在大部分浏览器的内核都是webkit，ie在10.0之前是完全不支持的，在10.0之后就是完全支持的，不用写浏览器前缀。 (2) 关键帧动画 1、定义关键帧动画：keyframes（关键帧动画）Webkit内核的浏览器器需要添加前缀(Safari,Chrome) -webkit-keyframes，-webkit-animation 123456789@keyframes dong &#123; from &#123; background-color: red; &#125; to &#123; background-color: blue; &#125;&#125;@-webkit-keyframes dong &#123;&#125;@keyframes dong &#123; 50% &#123; background-color: red; &#125; 100% &#123; background-color: blue; &#125;&#125; 2、调用并配置关键帧动画：animationanimation-name 动画名称animation-duration 动画时间animation-iteration-count: infinite; 动画次数animation-timing-function: ease; 时间函数animation-delay: 1s; 动画延迟时间animation-direction: reverse; 动画播放的方向 1234567normal 默认值 reverse 动画反向播放 alternate 第一次正向播放，第二次反向播放 alternate-reverse 第一次反向播放，第二次正向播放 如果把动画属性配置在animation中，各个属性的顺序可以打乱，但最好按照某一习惯性顺序，如果同时出现了两个时间值，第一个表示动画执行时间，第二个表示动画执行等待时间 123-webkit-animation: turn 10s linear;-o-animation: turn 10s linear;animation: turn 10s linear; (3)2D动画 (transform) 位移：123transform: translate(100px, 100px);transform: translateX(100px);transform: translateY(100px); 旋转：transform: rotate(45deg)(围绕对角线旋转) 缩放： 123transform: scale(1.5);transform: scaleX(1.5);transform: scaleY(1.5); 倾斜:12transform: skewX(45deg);transform: skewY(45deg); 同时使用多个: 会发生覆盖的问题 12transform: translate(100px, 100px)transform: skewX(45deg); 可以合写transform: translate(100px,100px)skewX(45deg);原点：会影响旋转所围绕的点，会影响缩放所参考的点1transform-origin: left top; (4)3D动画rotateX transform: rotateX(45deg);rotateY transform: rotateY(45deg);rotateZ 围绕Z轴进行行旋转默认围绕中心进行旋转translateZ 直接写没有效果的需要开启3D开启3D相关设置：transform-style: preserve-3d;添加给父元素该声明应用在3D变换的兄弟元素们的父元素上，也就是舞台元素perspective: 2000px; 添加给根节点(body或者html) 距离perspective-origin: 25% 75%;添加给父元素 值 X left | center | right Y top | center | bottom 设置基准点 backface-visibility: hidden; 翻转后设置背景不可见 (5)3D旋转盒子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465div &#123; width: 600px; height: 600px; position: absolute;&#125;#wrap &#123; font-size: 5em; position: relative; margin: 0 auto; /* 把父标签当做3d舞台*/ transform-style: preserve-3d; transition: all 5s;&#125;/* 父标签转动带动子标签旋转*/#wrap:hover &#123; transform: rotateX(360deg) rotateY(360deg) rotateZ(360deg);&#125;/*前面*/#div1 &#123; background-color:red; transform: translateZ(300px); -webkit-transform: translateZ(300px);&#125;/* 后面*/#div2 &#123; background-color: black; /* 绕Y轴180度*/ transform: rotateY(180deg) translateZ(300px); -webkit-transform: rotateY(180deg) translateZ(300px);&#125;/*左面*/#div3 &#123; background-color: yellow; /*绕y轴负方向90度*/ transform: rotateY(-90deg) translateZ(300px); -webkit-transform: rotateY(-90deg) translateZ(300px);&#125;/*右面*/#div4 &#123; background-color: hotpink; /*绕Y轴正方向90度*/ transform: rotateY(90deg) translateZ(300px); -webkit-transform: rotateY(90deg) translateZ(300px); &#125;/* 上面*/#div5 &#123; background-color: green; transform: rotateX(90deg) translateZ(300px); -webkit-transform: rotateX(90deg) translateZ(300px);&#125;/*下面*/#div6 &#123; background-color: orange; transform: rotateX(-90deg) translateZ(300px); -webkit-transform: rotateX(-90deg) translateZ(300px);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5入门]]></title>
      <url>%2F2016%2F08%2F08%2FHTML5%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[一、基本页面结构（H5新标签）页头： 1&lt;header&gt;&lt;/header&gt; 页面主体： 1&lt;main&gt;&lt;/main&gt; 划分页面子区域： 1&lt;section&gt;&lt;/section&gt; 解释了什么是WWF 1234&lt;section&gt; &lt;h1&gt;WWF&lt;/h1&gt; &lt;p&gt;The World Wide Fund for Nature (WWF) is....&lt;/p&gt;&lt;/section&gt; 页脚： 1&lt;footer&gt;&lt;/footer&gt; 版权： 1&lt;address&gt;&lt;/address&gt; 定义带有标签的文本： 1&lt;mark&gt;&lt;/mark&gt; 部分文本高亮显示: 1&lt;p&gt;Do not forget to buy &lt;mark&gt;milk&lt;/mark&gt; today.&lt;/p&gt; 时间： 1&lt;time&gt;&lt;/time&gt; 文章： 1&lt;article&gt;&lt;/article&gt;用article可以打破搜索引擎对h1标签的限制 广告： 1&lt;aside&gt;&lt;/aside&gt;展示和当前页面关系不大的内容（广告） 分割线： 1&lt;hr/&gt; 提示框： 1&lt;datalist&gt;&lt;/datalist&gt; option在提示框中展示的数据条目，value属性的值或在用户按下回车后填写进输入框，option的值会在条目侯勇浅灰色的字体显示用list和id设置一样的值来绑定 123456&lt;input list="device" /&gt; &lt;datalist id='device'&gt; &lt;option value="iPhone"&gt;iphone 7&lt;/option&gt; &lt;option value="ipad"&gt;&lt;/option&gt; &lt;option value="imac"&lt;/option&gt; &lt;/datalist&gt; 为input元素定义标注： 1&lt;label&gt;&lt;/label&gt; label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。要把label和input绑定就要把label中的for中的值跟input中的id设置相同 12&lt;label for=""&gt;用户&lt;/label&gt;&lt;input type="" id="" /&gt; 提示和注释： 1&lt;details&gt;&lt;/details&gt; 要与summery相配合使用，如果不用summery就是默认的标题，就是详细信息，而如果用summery就会更改默认的标题，默认只能看见标题，如果展开就会看见details中的内容，如果想要一进去就是看见展开的效果，就可以给details添加一个属性open，因为属性和属性值都是open，所以可以省略写只写一个就可以，以后只要是这种类似的都可以这样简写。 包裹图片、音频、视频： 1&lt;figure&gt;&lt;/figure&gt; 使用figcaption来给图片添加标题或讲解。 12345&lt;figure&gt; &lt;img src="" /&gt; &lt;figcaption id=""&gt; &lt;/figcaption&gt;&lt;/figure&gt; 进度条： 1&lt;progress&gt;&lt;/progress&gt; 有两个重要的属性，一个是value是当前值，还有一个是max是指完成的总值 12&lt;progress value="50" max="100"&gt;&lt;/progress&gt; 二、新表单元素旧的回顾： 单选框：radio 用name值来分组，如果不设置name值相同，就不是单选了，就可以同时选择多个选项 1234567男：&lt;input type="radio"name="gender" value="man"/&gt;女：&lt;input type="radio" name="gender" value="woman"/&gt;复选框：checkbox 游泳：&lt;input type="checkbox" value="youyong"/&gt;篮球：&lt;input type="checkbox" value="lanqiu"/&gt; 上传文件：file，但是只能选择一个文件，如果想要选择多个文件就可以添加一个属性，就是multiple，这个属性也是可以缩写成一个属性 1&lt;input type="file" multiple/&gt; 表单重置：reset因为用户体验不太好（总是会把登录和重置搞错），所以现在就不怎么用了，所以见得少 1&lt;input type="reset" value="重置"/&gt; 多行输入框：textarea 有两个属性：rows和cols可以用来控制输入框的大小，但是一般不用它们来控制，一般都是用width和height，因为这样对页面结构好掌控，因为页面都是以px像素来做的，不然不好控制。 1&lt;textarea name="" rows="8" cols="40"&gt;&lt;/textarea&gt; 下拉菜单：select,如果想多选也是可以加multiple这个属性，但是一般不用这么做，因为可以直接使用多选按钮 12345&lt;select class="" name="" multiple&gt; &lt;option value="iphone"&gt;iphone&lt;/option&gt; &lt;option value="ipad"&gt;ipad&lt;/option&gt; &lt;option value="ipod"&gt;iMac&lt;/option&gt;&lt;/select&gt; 新的： 日期：date 1&lt;input type="date" name="name" value=""&gt; 时间：time 1&lt;input type="time" name="name" value=""&gt; 星期:week 1&lt;input type="week" name="name" value=""&gt; 月份：month 1&lt;input type="month" name="name" value=""&gt; 邮箱：email 1&lt;input type="email" name="name" value=""&gt; 网址：url 1&lt;input type="url" name="name" value=""&gt; 数值：number 1&lt;input type="number" name="name" value=""&gt; 范围：range，有三个属性，最小值min，最大值;max,还有一个就是步调，一次移动多少。 1&lt;input type="range" name="name" value="" min="0" max="100" step="50"&gt; 颜色：color 1&lt;input type="color" name="name" value=""&gt; 搜素框：search 1&lt;input type="search" name="name" value=""&gt; 三、新标签属性tabindex：用来设置标签可以通过tab按键选中通过这个属性可以设置tab按键按下时选择标签顺序编号 123&lt;p tabindex="1"&gt;哈哈&lt;/p&gt;&lt;p tabindex="2"&gt;嘻嘻&lt;/p&gt;&lt;p tabindex="3"&gt;嘿嘿&lt;/p&gt; required:如果某一个表单元素配置了该属性，则该元素必须有值，否则数据无法提交 12345&lt;form class="" action="http://www.baidu.com" method="get"&gt; &lt;input type="" name="name" value="" required&gt; &lt;input type="" name="name" value=""&gt; &lt;input type="submit" name="name" value=""&gt;&lt;/form&gt; hidden隐藏且不占空间 1&lt;p hidden&gt;啦啦&lt;/p&gt; 四、隐藏方式的总结1.给标签设置display:none,标签隐藏且不占页面位置 2.给标签设置opcity:0,标签隐藏但是占据页面位置 3.给标签设置宽高都为0，overflow:hidden，标签隐藏且不占据页面位置 4.给标签设置visibility：hidden，标签隐藏但是占据页面位置 五、拖放处理步骤： a定义可拖动目标b定义被拖动的数据，可能为多种不同格式c允许设置拖拽效果d定义放置区域e在drop发生的时候做一些事情 1、拖拽目标的开始的拖拽事件：ondragstart 在开始拖拽事件中e对象中有一个dataTransfer属性，用来保存被拖动的数据e.dataTransfer也是一个对象，可以保存数据，但是不能通过“.”语法来访问和设置该属性，有getData和setData两个方法来进行设置和访问该属性，可以保存一个或多个数据，在所有拖动事件中该属性都是可用的，但是不能单独创建 123img.ondragstart = function(e)&#123; e.dataTransfer.setData("type/img",this.id);&#125; 2、拖拽目标的结束的拖拽事件：ondragend 123img.ondragend = function()&#123; console.log("目标拖拽结束")&#125; 3、拖拽目标进入当前标签：ondragenter 1234div1.ondragenter = function()&#123; console.log("目标进来了"); div1.style.boxShadow = "0 0 20px red" &#125; 4、拖拽目标在当前标签之上 div1.ondragover = function(){ console.log(“djsaf”); return false;}5、拖拽离开事件 1234div1.ondragleave = function()&#123; console.log("拖拽离开了"); div1.style.boxShadow = "none"; &#125; 6、拖拽松开事件 123456789div1.ondrop = function(e)&#123; console.log("目标放入"); var id = e.dataTransfer.getData("type/img"); var img = document.querySelector(a); this.appendChild(img); img.style.position = 'absolute'; img.style.top = "-"+(img.offsetHeight-div1.offsetHeight)/2+"px; img.style.left = "-"+(img.offsetWidth-div1.offsetWidtht)/2+"px";&#125; 六、把电脑里的图片拖放到浏览器中123456789101112131415161718192021222324252627282930313233343536// 获取拖拽目的地的标签 var wrap = document.querySelector("#wrap"); // 给拖拽目的地添加enter和leave事件，修改css样式 wrap.ondragenter = function() &#123; this.style.backgroundColor = "gray"; &#125; wrap.ondragleave = function () &#123; this.style.backgroundColor = "white"; &#125; // 取消over事假的默认事件，保证drop事件能被触发 wrap.ondragover = function() &#123; return false; &#125; // 拿到拖拽目的地的drop事件，取消默认事件 wrap.ondrop = function(e) &#123; // 松手后背景颜色变白 this.style.backgroundColor = "white"; // 获取到拖拽进来的文件 var file = e.dataTransfer.files[0]; // 创建文件读取对象，来读取file中的数据。 var fileReader = new FileReader(); // 当文件读取对象读取完毕后，获取到读出来的数据 fileReader.onload = function (e) &#123; // 获取按照指定格式读取出来的数据 // 获取图片数据的方式 // 1、e.target.result; // 2、fileReader.result; var data = e.target.result; // 把读取出来的数据设置为div的背景图展示出来 wrap.style.background = "url("+data+") no-repeat center"; wrap.innerText = ''; &#125; // 读取文件 fileReader.readAsDataURL(file) return false; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Touch事件]]></title>
      <url>%2F2016%2F05%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFTouch%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[一、与PC端事件的差异对比1.PC端的mousemove、mouseup、mousedown等事件，在移动端会失效(或者使用不正常)2.PC端的click事件可以使用，但是会有300ms的延迟问题 300ms的延迟问题： 123456781.click事件在移动手机开发中会有300ms的延迟问题，因为在手机早期，浏览器有大和缩小的功能， 用户在屏幕上点击两次之后，浏览器会触发放大或缩小的功能，因此浏览器做了一个处理，当触摸一 次后，在300ms这段时间内有没有触摸第二次，如果触摸了第二次，说明是触发放大或缩小功能，否 则的话就是click事件， 因此在click 的时候，用户必须等待300ms之后才会触发click事件。所 以当在移动端使用click事件的时候，会感觉到300ms的迟钝。 2.在实际应用中发现，300ms并不是绝对发生，当用户设置了viewport并禁止缩放时，大部分浏览器 会禁止300ms延迟，但在低版本安卓以及微信，qq等应用的内嵌webview中仍然会发生300ms延迟问题 二、移动端手势事件1.touchstart : 手指按下的时候触发 2.touchmove :手指移动的时候触发 3.touchend ： 手指离开时触发 4.touchcancel : 事件被打断的时候触发(来电话等) 5.事件的执行顺序： touchstart——touchmove——touchend——click 三、 TouchTouch对象代表一个触点，可以通过event.touches[0]获取，每个触点包含位置，大小，形状，压力大小，和目标 element属性。 1234567891011121314&#123; screenX: 511, screenY: 400,//触点相对于屏幕左边沿的Y坐标 clientX: 244.37899780273438, clientY: 189.3820037841797,//相对于可视区域 pageX: 244.37, pageY: 189.37,//相对于HTML文档顶部，当页面有滚动的时候与clientX=Y 不等 force: 1,//压力大小，是从0.0(没有压力)到1.0(最大压力)的浮点数 identifier: 1036403715,//一次触摸动作的唯一标识符 radiusX: 37.565673828125, //能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴)半径 radiusY: 37.565673828125, rotationAngle: 0,//它是这样一个角度值：由radiusX 和 radiusY 描述的正方向的椭圆，需要通过顺时针旋转这个角度值，才能最精确地覆盖住用户和触摸平面的接触面 target: &#123;&#125; // 此次触摸事件的目标element&#125; identifier这个属性大家可能有疑惑，使用 Chrome 的模拟器发现多次触摸动作，值始终不变。用真机测试则不会有问题(我这里用的safari连接mac调试)。每次触摸包括start,move,end这整个过程，标志符都不变。下一次触摸动作开始，标志符就会变化。 screenY clientY在 safari 中 screenY与clientY值是相等的，在iOS微信中两个数值不等，但单位应该也不一样。 radiusX radiusY rotationAngle测试过程中safari及微信内置浏览器都不支持这些属性，chrome模拟器可以。 TouchList由Touch对象构成的数组，通过event.touches取到。一个Touch对象代表一个触点，当有多个手指触摸屏幕时，TouchList就会存储多个Touch对象，前面说到的identifier就用来区分每个手指对应的Touch对象。 TouchEventTouchEvent就是用来描述手指触摸屏幕的状态变化事件，除了一般DOM事件中event对像具备的属性，还有一些特有的属性 touches一个TouchList对象，包含当前所有接触屏幕的触点的Touch对象，不论 touchstart 事件从哪个elment上触发。 targetTouches也是一个TouchList对象，包含了如下触点的 Touch 对象：touchstart从当前事件的目标element上触发 changedTouches也是一个 TouchList 对象，对于 touchstart 事件, 这个 TouchList 对象列出在此次事件中新增加的触点。对于 touchmove 事件，列出和上一次事件相比较，发生了变化的触点。对于 touchend ，列出离开触摸平面的触点（这些触点对应已经不接触触摸平面的手指）。 touchend这里要特别注意，touches和targetTouches只存储接触屏幕的触点，要获取触点最后离开的状态要使用changedTouches。 四、做一个touch事件库只是练习原理，其中还有很多不全面，可以使用第三方库来实现效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120;(function()&#123; var query = function(selector)&#123; //一开始调用$(选择器)就是需要执行init方法，因为需要得到元素才可以做下面的操作，所以这样的话就必须使用链式调用的样子，返回出来this对象 //其实本来方法中this都是指query.fn的对象，因为是执行了init方法后直接调用了tap方法，所以tap里面的this应该是指向调用者，就是init返回出来的值， //但是又是query.fn对象的方法，所以需要返回出来this才能继续下面的方法调用，如果直接返回元素，就没有tap方法了，也就调用不了 return query.fn.init(selector); &#125; query.fn = query.prototype = &#123; //初始化方法 init:function(selector)&#123; if(typeof selector == 'string')&#123; this.element = document.querySelector(selector); return this; &#125; &#125;, //单击事件 tap:function(handler)&#123; this.element.addEventListener("touchstart",touchFn); this.element.addEventListener("touchend",touchFn); //声明按下时间和结束时间（用来判断是否是合理的单击操作） var startTime,endTime; //事件触发函数 function touchFn(e)&#123; switch (e.type)&#123; case "touchstart": //记录按下时间 startTime = new Date().getTime(); break; case "touchend" : //记录结束时间 endTime = new Date().getTime(); if(endTime - startTime &lt;= 400)&#123; //回调 handler(); &#125; break; &#125; &#125; &#125;, #### //双击 doubleTap:function(handler)&#123; this.element.addEventListener('touchstart',dbltouchFn); this.element.addEventListener('touchend',dbltouchFn); var count = 0; var timerId; function dbltouchFn(e)&#123; switch (e.type)&#123; case "touchstart": count++; clearTimeout(timerId); timerId = setTimeout(function()&#123; count = 0; &#125;,300) break; case "touchend" : //记录结束时间 endTime = new Date().getTime(); if(count == 2)&#123; //回调 handler(); count=0; &#125; break; &#125; &#125; &#125;, #### //长按 longTap:function(handler)&#123; this.element.addEventListener("touchstart",touchFn); this.element.addEventListener("touchend",touchFn); this.element.addEventListener("touchmove",touchFn); //事件触发函数 function touchFn(e)&#123; switch (e.type)&#123; case "touchstart": //按下500ms后才算是长按，执行回调函数 timerId = setTimeout(function()&#123; handler(); &#125;,500) break; case "touchend" : clearTimeout(timerId) break; case "touchmove" : clearTimeout(timerId) break; &#125; &#125; &#125;, #### //左滑事件 swiperLeft:function(handler)&#123; this.element.addEventListener("touchstart",touchFn); this.element.addEventListener("touchend",touchFn); //声明坐标变量 var startX,startY,endX,endY; function touchFn(e)&#123; switch (e.type)&#123; case "touchstart": startX = e.targetTouches[0].pageX; startY = e.targetTouches[0].pageY; break; case "touchend" : endX = e.changedTouches[0].pageX; endY = e.changedTouches[0].pageY; //1.判断是上下滑动还是左右滑动 //2.判断是左还是右(阈值); if(Math.abs(endX - startX) &gt;= Math.abs(endY - startY) &amp;&amp; ((startX - endX) &gt; 40))&#123; handler(); &#125; break; &#125; &#125; &#125; &#125; query.fn.init.prototype = query.fn; window.$ = window.query = query; &#125;)();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs]]></title>
      <url>%2F2016%2F02%2F08%2FAngularJs%2F</url>
      <content type="text"><![CDATA[一、Angular简介1.Angular是什么?为动态web应用设计的结构框架 2.为什么要使用?(1)angularJS是一个单页应用(SPA)框架(2)前后端分离，后端只提供数据接口，路由，模板渲染在前端完成(3)HTML和JS分离，展示和逻辑分离(4)减少JS代码，减少DOM元素查找，事件绑定等代码(5)适合API开发 二、Angular核心特性功能(1)双向数据绑定实现了view和model完全绑定了在一起，model变化，view也变化，反之亦然。 (2)模板模板相当于HTML文件被浏览器解析到DOM中，AngularJS遍历这些DOM，AngularJS把模板当做DOM来操作，去生成一些指令来完成对view的数据绑定 (3)MVCModel-View-Controller(模型-视图-控制器)1、为什么需要MVC?(1)代码规模越来越大，需要将不同的系统功能切分成不同的模块（JS文件），这样有助于让不同的开发人员去实现，简单来说就是切分职责是大势所趋；(2)为了复用公共的模块——很多模块的逻辑是一模一样的；(3)为了后期维护的方便——修改一切功能不影响其他功能。 MVC只是手段，终极目标是模块化和复用！！！要学会区分手段和目的。2、前端MVC的困难在哪里？ 如上图所示，首先浏览器内部会加载JS脚本，然后进行JIT编译执行，在这执行过程中，会给我们带来如上图右边的一些常见的困难： (1)如DOM的操作会受到浏览器加载影响——浏览器在加载脚本时，不同的浏览器会有不同的实现方式，包括加载的顺序以及并发的线程数量都是有不同的；(2)如果模块之间出现依赖关系（JS文件依赖），JS并没有为我们提供现成的解决工具，需要自己手工去解决；(3)JS本身的语言机制，例如原型继承，也没有像其他语言有现成的继承工具，需要自己去模拟继承去完成想要的效果； 以上，是所有以JS为基础开发的框架都会面临的问题 3、AngularJS语境下的MVC是如何实现的? 控制器——Controller常见的MVC——controller的实现方式1：控制器和视图进行双向交互，和数据模型也进行双向交互，但视图和模型之间没有双向交互，我们会把多个视图的逻辑控制都放在同一个控制器内，对于小型项目还好，但没办法应对大型项目。MVC——controller的实现方式2：改进：一个控制器只跟一个视图进行双向交互，两个视图共用同个数据模型只需在对应的的控制器里管理就好问题：如果两个视图的控制器里面出现相同的内容，该如何管理？改进：将公共的部分抽出，生成一个通用控制器，然后继承这个通用控制器，但通常在AngularJS中不建议这样做正确的打开方式是：将通用的部分抽成一个Service,让控制器去调用。Controller使用过程中的注意点（使用原则）： (1)不要试图去复用Controller,一个控制器一般只负责一小块视图——AngularJS的Controller通常处理的是业务逻辑；(2)不要在Controller中操作DOM，这不是控制器的职责——有封装好的操作DOM的机制Directive；(3)不要在Controller里面做数据格式化，ng有很好用的表单控件；(4)不要在Controller里面做数据过滤操作,ng有$fliter服务；(5)一般来说，Controller是不会相互调用的，控制器之间的交互会通过事件进行。 模型——modelAngularJS中使用指令ng-model来生成数据模型，通常是绑定在$scope对象上实现。是指从服务器中获取的数据，在任何UI上看到的数据都是从模型或者其子模型中获取的123Your name: &lt;input type="text" ng-model="yourname" placeholder="World"&gt; &lt;hr&gt; Hello &#123;&#123;yourname || 'World'&#125;&#125;! 模型和控制器 在PhoneListCtrl控制器里面初始化了数据模型（这里只不过是一个包含了数组的函数，数组中存储的对象是手机数据列表）： app/js/controller.js: 12345678910function PhoneListCtrl($scope) &#123; $scope.phones = [ &#123;"name": "Nexus S", "snippet": "Fast just got faster with Nexus S."&#125;, &#123;"name": "Motorola XOOM™ with Wi-Fi", "snippet": "The Next, Next Generation tablet."&#125;, &#123;"name": "MOTOROLA XOOM™", "snippet": "The Next, Next Generation tablet."&#125; ];&#125; 尽管控制器看起来并没有起到什么控制的作用，但是它在这里起到了至关重要的作用。通过给定我们数据模型的语境，控制器允许我们建立模型和视图之间的数据绑定。我们是这样把表现层，数据和逻辑部件联系在一起的： PhoneListCtrl——控制器方法的名字（在JS文件controllers.js中）和标签里面的ngController指令的值相匹配。 手机的数据此时与注入到我们控制器函数的作用域（$scope）相关联。当应用启动之后，会有一个根作用域被创建出来，而控制器的作用域是根作用域的一个典型后继。这个控制器的作用域对所有标记内部的数据绑定有效。 AngularJS的作用域理论非常重要：一个作用域可以视作模板、模型和控制器协同工作的粘接器。AngularJS使用作用域，同时还有模板中的信息，数据模型和控制器。这些可以帮助模型和视图分离，但是他们两者确实是同步的！任何对于模型的更改都会即时反映在视图上；任何在视图上的更改都会被立刻体现在模型中。 视图——view可以浏览和使用的UI界面 (4)依赖注入拥有内建的依赖注入子系统，可以帮助开发人员更容易的开发，理解和测试应用 概念： Dependency Injection 简称DI 是一种软件设计模式一个或多个的依赖注入到一个独立的对象中，然后成为该客户端的一部分 1、推断式注入缺点：不利于压缩 可以用来创建自定义标签，也可以用来装饰元素，操作DOM属性 2、声明式注入/标注式注入利用$inject 3、内联式注入这样的话方法的名称没必要和需要注入的东西一模一样，这样使用压缩工具后也不会报错 AngularJS 提供很好的依赖注入机制。以下5个核心组件用来作为依赖注入：12345valuefactoryserviceproviderconstant provider是基础，其他的都要调用provider，可以通过源码看到： (1)providerprovide中提供一个$get方法，用于返回value/service/factory 123456789101112131415// 定义一个模块var mainApp = angular.module("mainApp", []);...// 使用 provider 创建 service 定义一个方法用于计算两数乘积mainApp.config(function($provide) &#123; $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;);&#125;); (2)factoryfactory 是一个函数用于返回值。在 service 和 controller 需要时创建。 1234567891011121314151617181920// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 factory "MathService" 用于两数的乘积 provides a method multiply to return multiplication of two numbersmainApp.factory('MathService', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b &#125; return factory;&#125;); // 在 service 中注入 factory "MathService"mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125;&#125;);... (3)service服务十一分单一的JS包含了一组函数对象来执行某些任务，经常用服务去处理数据请求 1234567891011121314//通过service创建一个数据请求服务// 注意：服务里不能用$scopeapp.service('HTTPProcuctService', function ($http) &#123; return &#123; //获取slide和菜单项数据接口 loadSliderAndMenuData : function () &#123; return $http.get("http://www.vrserver.applinzi.com/aixianfeng/apihome.php"); &#125;, //获取hot商品列表 loadHotProductData : function () &#123; return $http.get("http://www.vrserver.applinzi.com/aixianfeng/apihomehot.php"); &#125; &#125;&#125;) (4)valuevalue是一个简单的JavaScript对象，用于向控制器传递值(配置阶段)； 12345678910111213141516// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 value 对象 "defaultInput" 并传递数据mainApp.value("defaultInput", 5);...// 将 "defaultInput" 注入到控制器mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125;&#125;); (5)constantconstant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。1mainApp.constant("configParam", "constant value"); (5)指令1、Angular指令AngularJS 指令是扩展的 HTML 属性，带有前缀 ng-。ng-app 指令初始化一个 AngularJS 应用程序。ng-init 指令初始化应用程序数据。ng-model 指令把元素值（比如输入域的值）绑定到应用程序。ng-repeat 指令会重复一个 HTML 元素： 12345678&lt;div ng-app="" ng-init="names=['Jani','Hege','Kai']"&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 2、自定义指令 1234567891011121314151617var app = angular.module('myApp', []);// 注意：如果自定义指令包含大写字母的话，// 使用的时候需要用-分割开，例如xiaoXue 对应 xiao-xueapp.directive('xiaoXue', function () &#123; return &#123; //这个属性不设置的话，默认：标签和属性形式生效， //设置后，设置哪个就哪个生效 restrict : 'A', //replace : true 会把替换掉当前页面的元素， //如果使用注释形式的话，必须设置这个属性 replace : true, //template : "&lt;h1&gt;我是自定义H1&lt;/h1&gt;" //也可以链接一个页面地址 注意：一定要是纯页面，不能有注释和脚本 templateUrl : "../footer.html" &#125;&#125;) 调用属性方法 三、angular过滤器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;body ng-app=""&gt; &lt;div ng-init="str='abcde'; money=12345"&gt; &lt;h1&gt;货币格式化处理（currency）&lt;/h1&gt; &lt;!-- 默认是美元 --&gt; &lt;h2&gt;&#123;&#123; money | currency &#125;&#125;&lt;/h2&gt; &lt;!-- 可以自定义任何货币 --&gt; &lt;h2&gt;&#123;&#123; money | currency : "RMB￥" &#125;&#125;&lt;/h2&gt; &lt;h1&gt;字母大小写格式处理&lt;/h1&gt; &lt;h2&gt;&#123;&#123; str | uppercase &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; "ABC" | lowercase &#125;&#125;&lt;/h2&gt; &lt;h1&gt;限制字符串或数组的长度&lt;/h1&gt; &lt;!-- 限制字符串的长度 --&gt; &lt;h2&gt;&#123;&#123; str | limitTo : 3 | uppercase&#125;&#125;&lt;/h2&gt; &lt;!-- 限制数组的长度--&gt; &lt;h2&gt;&#123;&#123; ([33, 44, 22, 55] | limitTo : 2)[1] &#125;&#125;&lt;/h2&gt; &lt;h1&gt;给数字设置千分位&lt;/h1&gt; &lt;h2&gt;&#123;&#123; 1234567 | number &#125;&#125;&lt;/h2&gt; &lt;!-- 设置参数就可以保留小数 --&gt; &lt;h2&gt;&#123;&#123; 1234567 | number : 2 &#125;&#125;&lt;/h2&gt; &lt;!-- 是四舍五入的 --&gt; &lt;h2&gt;&#123;&#123; 1234567.996 | number : 2 &#125;&#125;&lt;/h2&gt; &lt;h1&gt;日期格式化处理&lt;/h1&gt; &lt;!--&#123;&#123;date (毫秒数) | date : 'yyyy-MM-dd hh:mm:ss EEEE'&#125;&#125;--&gt; &lt;!-- 格式化可以自定义 --&gt; &lt;h2&gt;&#123;&#123; 1481076346614 | date : 'yyyy年-MM月-dd日 hh:mm:ss EEEE'&#125;&#125;&lt;/h2&gt; &lt;h1 ng-init="arr=[33, 22, 44, 55]; persons=[&#123;name:'b', age:18&#125;, &#123;name:'a', age:20&#125;, &#123;name:'c', age:17&#125;, &#123;name:'ca', age:16&#125;, &#123;name:'cb', age:18&#125;, &#123;name:'ab', age:28&#125;]"&gt; 排序（将来用作于接口返回数据后的前端排序） &lt;/h1&gt; &lt;!-- 普通数组排序 默认是升序 --&gt; &lt;h2&gt;&#123;&#123; arr | orderBy &#125;&#125;&lt;/h2&gt; &lt;!-- 降序的话需要加入参数是 order:true --&gt; &lt;h2&gt;&#123;&#123; arr | orderBy : order : true &#125;&#125;&lt;/h2&gt; &lt;!-- 数组中有对象，按照对象的某个属性去排序 --&gt; &lt;h2&gt;&#123;&#123; persons | orderBy : 'age' &#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; persons | orderBy : 'age' : true &#125;&#125;&lt;/h2&gt; &lt;!-- 在ng-repeat中使用 --&gt; &lt;ul&gt; &lt;li ng-repeat="person in persons | orderBy : 'age'"&gt; &#123;&#123; person.age &#125;&#125; === &#123;&#123; person.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 排序小功能 --&gt; 条件过滤： &lt;input type="text" ng-model="queryFilter" /&gt; 排序条件： &lt;select ng-model="orderType"&gt; &lt;option value="name"&gt;按照名字排序&lt;/option&gt; &lt;option value="age"&gt;按照年龄排序&lt;/option&gt; &lt;/select&gt; &lt;ul&gt; &lt;li ng-repeat="person in persons | filter : queryFilter | orderBy : orderType"&gt; &#123;&#123; person.age &#125;&#125; === &#123;&#123; person.name &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 四、angular内置服务1234567891011121314151617181920212223242526272829angular.module('myApp', []) .controller('ctrl', function ($scope, $timeout, $location, $http) &#123; setTimeout(function () &#123; $scope.name = "小雪"; alert($scope.name); &#125;, 2000); $timeout(function () &#123; $scope.name = "小雪"; &#125;, 2000); console.log($location); console.log($location.absUrl()); console.log($location.protocol()); console.log($location.host()); console.log($location.port()); $http.get("http://www.vrserver.applinzi.com/aixianfeng/apihome.php") .success(function (data) &#123; console.log(data); &#125;); &#125;) .controller('ctrl2', function ($scope, $interval) &#123; $scope.count = 0; var timerId = $interval(function () &#123; $scope.count++; if ($scope.count == 5) &#123; $interval.cancel(timerId); &#125; &#125;, 1000); &#125;) 五、angular监听12345678910111213141516171819202122232425var app = angular.module('myApp', []); app.controller('ctrl', function ($scope) &#123; $scope.count = 0; $scope.btnFn = function (e) &#123; e.stopPropagation(); $scope.count++; &#125; window.onclick = function () &#123; $scope.$apply(function () &#123; $scope.count++; &#125;) &#125; //只会监听到angular环境中对变量的改变， //不会去监听原生环境中对变量的改变 $scope.$watch('count', function (newValue, oldValue) &#123; console.log('old：' + oldValue + "===" + 'new：' + newValue); &#125;) setTimeout(function () &#123; $scope.count++; &#125;, 1000);&#125;) 六、angular路由1、载入了实现路由的 js 文件：angular-route.js。 2、包含了 ngRoute 模块作为主应用模块的依赖模块。 1angular.module('routingDemoApp',['ngRoute']) 3、使用 ngView 指令 1&lt;div ng-view&gt;&lt;/div&gt; 该 div 内的 HTML 内容会根据路由的变化而变化。4、配置 $routeProvider，AngularJS $routeProvider 用来定义路由规则。 123456789101112131415161718192021222324252627282930313233343536// 这里需要导入ngRoute模块 才可以使用路由功能// 导入angularCSS 可以关联样式var app = angular.module('myApp', ['ngRoute', 'angularCSS']);// 通过config方法来，依赖注入$routeProvider服务，// $routeProvider服务来配置路由规则app.config(['$routeProvider', function ($routeProvider) &#123; $routeProvider .when('/home/:userName/:age', &#123; templateUrl : "./views/home.html", controller : function ($scope, $css) &#123; $scope.pageName = "这是home"; $css.add('./css/home.css'); &#125; controller : 'homeCtrl' &#125;) .when('/supermarket', &#123; templateUrl : "./views/supermarket.html", controller : 'supermarketCtrl' &#125;) .when('/cart', &#123; templateUrl : "./views/cart.html", controller : 'cartCtrl' &#125;) .when('/mine', &#123; templateUrl : "./views/mine.html", controller : 'mineCtrl' &#125;) .when('/productInfo/:productId', &#123; templateUrl : "./views/productInfo.html", controller : 'productInfoCtrl' &#125;)&#125;]); template: 如果我们只需要在 ng-view 中插入简单的 HTML 内容，则使用该参数： 1.when('/computers',&#123;template:'这是电脑分类页面'&#125;) templateUrl: 如果我们只需要在 ng-view 中插入 HTML 模板文件，则使用该参数： 123$routeProvider.when('/computers', &#123; templateUrl: 'views/computers.html',&#125;); 5.$route $route用于将控制器与视图相连，他观察$location.url(),并且尝试映射路径到一个已经存在的路由定义中，他依赖$location、$routeParams 6.$routeParams $routeParams允许你检索当前路由的参数 12345&lt;!--router.js--&gt;.when('/productInfo/:productId', &#123; templateUrl : "./views/productInfo.html", controller : 'productInfoCtrl'&#125;) 12345app.controller('productInfoCtrl', function ($scope, $routeParams) &#123;// $scope.a = $routeParams.productName; $scope.b = $routeParams.productId; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端布局]]></title>
      <url>%2F2015%2F07%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[一、视口 viewport手机有不不同的分辨率，不不同的屏幕大小，如何使我们开发的应用或页面大小能适合各种高端手机使用？学习html5 viewport能帮助我们实现这一点。 123456789101112131415161718192021222324width=device-width 设置宽度为屏幕宽度maximum-scale=1.0 设置最大缩放比例0.25 — 10.0 minimum-scale=1.0设置最小缩放比例:不能小于初始化的比例0.25 — 10.0 user-scalable=no 禁止用户捏合 width=device-width height=device-height 设置宽度为屏幕的宽度/设置⾼高度为屏幕的高度可以设置⼀一个固定的值 尽可能不不这样使用设置为设备的宽度： device-width height是设置高度使用的，我们很少使用 initial-scale=1.0 设置初始化的缩放比例 maximum-scale=1.0 minimum-scale=1.0 设置最大缩放比和最小缩放比值的范围是0.25 ~ 10.0user-scalable=no user-scalable=0 是否允许用户进行缩放网页 值yes(默认) / 1no / 0如果设置为no，那么minimax-scale和maximum-scale将被忽略，因为不不允许缩放 所以一般我们可以复制这段到我们的项目中 1&lt;meta name="viewport"content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,uer-scalable=no" /&gt; 二、响应式布局定义为不不同屏幕分辨率定义不不同的布局使一个网站能兼容多个终端—而不不是为每个终端做一个特定的版本 这个概念是为了了解决移动互联网浏览而诞生的 。 为什什么需要？响应式布局可以为不不同终端的用户提供更更加舒适的页面和更更好的用户体验随着目前大屏幕移动设备的普及，可以用“大势所趋”来形容。 CSS3加入的媒体查询使得无需修改内容便便可以使样式应用于某些特定的设备范围 作用 通过不不同的屏幕大小定义不不同的样式 媒体查询的大部分媒介特性都接收min和max用于表达：大于或等于和小于或等于 媒体类型 ：screen 屏幕print 打印机默认为all，我们通常写screen媒体属性min-widthmax-width逻辑操作符and用来把多个媒体属性组合起来，合并到同一条媒体查询中 样式表中内嵌@media 1234567891011div &#123; width: 100px; height: 100px; background: red; &#125;@media only screen and (min-width: 1000px) and (max-width: 1100px)&#123; div &#123; background: yellow; &#125;&#125; 在link中使用@media 1&lt;link rel=“stylesheet” type=“text/css” media=“only screen and (max-width: 480px)” href=“link.css”&gt; 三、多列布局简介：CSS多列列布局继承自块级布局模式，允许简单地定义多列文本 当阅读文字的时候，从干一行末尾移动到下一行开始处，容易弄错读到了哪一行。为了最优化使用大的显示屏幕，设计中应限制文字段落的宽度而并列列排布类似报纸 使用 ： 列数和宽度： 设置列数： column-count 设置每列列宽度 ：column-width columns ：column-count和column-width的简写,优先保证宽度，在宽度至少能达到指定宽度时，设置列列数 123columns: 5;columns: 20em;columns: 12 8em; 列间隙 ：列之间的间隙建议值为1em 123column-gapcolumn-gap: 2em;column-gap: 20px; 优雅降级(浏览器器兼容性)： 多列属性会被不支持多列模型的浏览器器忽略 注意不是所有的浏览器器都支持不带前缀的属性 12-moz--webkit- 写的时候最好写三次 123-webkit-columns: 3;-moz-columns: 3;columns: 3; 列边框设置： 12345column-rule-width： 5px; thin 最窄 medium 中等 thick 最厚 column-rule-colorcolumn-rule-style 和border-style的值一样column-rule 复合属性 1column-rule: 2px solid cyan; 跨列列 ： 1column-span all 指定元素跨越所有列 四、用户界面简介 在CSS3中，增加了一些新的用户界面特性来跳转元素尺寸，框尺寸和外边框。1.resize :指定了某个元素是否可以由用户调整大小使用时，需要添加 overflow: auto;值vertical 竖直方向horizontal 水平方向both 都2.outline-offset 轮廓相关属性 :outline-width(2)outline-style(2)outline-color(2)outline(2) :轮廓特点 不占用空间轮廓偏移值 1outline-offset: 10px; 3.text-overflow当文本超出时，应该显示什么值ellipsis …clip 直接被裁剪掉配合属性overflow: hidden;white-space: no-wrap; 12345678910111213141516171819202122232425262728#div1 &#123; width: 100px; height: 100px; border: 1px solid red; overflow: auto; resize: horizontal; &#125; #p1 &#123; width: 8rem; border: 1px solid green; outline: 1px dotted red; outline-offset: 5px; &#125; #p2 &#123; width: 10rem; height: 1rem; border: 1px solid gray; /*overflow: hidden;*/ white-space: nowrap; text-overflow: ellipsis; white-space: normal; &#125; 4.cursor 123456789101112131415&lt;p id="p1" style="cursor:none"&gt;none&lt;/p&gt; &lt;p id="p2" style="cursor: context-menu;"&gt;contentxt-menu&lt;/p&gt; &lt;p id="p3" style="cursor: cell;"&gt;cell&lt;/p&gt; &lt;p id="p4" style="cursor: vertical-text;"&gt;vertical-text&lt;/p&gt; &lt;p id="p5" style="cursor: alias;"&gt;alias&lt;/p&gt; &lt;p id="p6" style="cursor: copy;"&gt;copy&lt;/p&gt; &lt;p id="p7" style="cursor: no-drop;"&gt;no-drop&lt;/p&gt; &lt;p id="p8" style="cursor: not-allowed;"&gt;not-allowed&lt;/p&gt; &lt;p id="p9" style="cursor: nesw-resize;"&gt;nesw-resize&lt;/p&gt; &lt;p id="p10" style="cursor: nwse-resize;"&gt;nwse-resize&lt;/p&gt; &lt;p id="p11" style="cursor: col-resize;"&gt;col-resize&lt;/p&gt; &lt;p id="p12" style="cursor: row-resize;"&gt;row-resize&lt;/p&gt; &lt;p id="p13" style="cursor: all-scroll;"&gt;all-scroll&lt;/p&gt; &lt;p id="p14" style="cursor: zoom-in;"&gt;zoom-in&lt;/p&gt; &lt;p id="p15" style="cursor: zoom-out;"&gt;zoom-out&lt;/p&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex布局]]></title>
      <url>%2F2015%2F07%2F08%2FFlex%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[一、Flexible Box Layout弹性布局：提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间 二、概念容器：采用flex布局的元素都称为容器Flex Container项目：容器内所有子元素自动成为容器成员，称为项目 Flex item两根轴： 1234567891.main axis(主轴) ： 容器中水平的称为主轴，mian start 主轴的开始位置 main end主轴的结束位置 2.cross axis（交叉轴）: 容器器中垂直的称为交叉轴,crossstart交叉轴的开始位置,cross end 交叉轴的结束位置 项目默认按照主轴排序main size 单个项目占据的主轴空间cross size 单个项目占据的交叉轴空间 三、使用任何容器器都可以指定为flex布局 123.box &#123; display: flex; &#125; flex布局之后，子元素成为内联块元素行内元素也可以使用flex布局 123.box section &#123; display: inline-flex; &#125; 注意 设置后，float / clear / vertical-align 将失效 四、容器的属性1.flex-direction ：决定主轴方向 12345flex-direction: row | row-reverse | column | column-reverse; row (默认值) 主轴为水平方向，起点在左端 row-reverse 主轴为水平方向，起点在右端 column 主轴为垂直方向，起点在上沿 column-reverse 主轴为垂直方向，起点在下沿 123456789.flex-container &#123; display: -webkit-flex; display: flex; -webkit-flex-direction: row-reverse; flex-direction: row-reverse; width: 400px; height: 250px; background-color: lightgrey; &#125; 2.flex-wrap:默认情况下，项目都排在一条线（轴线) 1234567891011121314如果一条轴线排不下，flex-wrap决定该如何换行 no-wrap (默认) 不换行 wrap 换行，第一行在上方 wrap-reverser换行,第一行在下方 .flex-container &#123; display: -webkit-flex; display: flex; -webkit-flex-wrap: nowrap; flex-wrap: nowrap; width: 300px; height: 250px; background-color: lightgrey; &#125; 3.flex-flow ：flex-flow属性是flex-direction属性和flex-wrap的简写形式类似background默认值 row no-wrap4.justify-content：定义了了项目在主轴上的对齐方式 12345678justify-content: flex-start | flex-end | center | space-between | space-around; 值（假设主轴从左到右） flex-start：左对齐 flex-end : 右对齐 center : 中点对齐 space-between : 两端对齐，项⽬目之间的间隔相等 space-around : 每个项目两侧的间隔相等,所以，项⽬目之间的间隔比项目 与边框的间隔大一倍 123456789.flex-container &#123; display: -webkit-flex; display: flex; -webkit-justify-content: flex-end; justify-content: flex-end; width: 400px; height: 250px; background-color: lightgrey; &#125; 5.align-items: 假设交叉轴从上到下 12345flex-start：上对齐 flex-end ： 下对齐 center ： 中点对齐 baseline ： 项目的第一行文字的基线对齐 stretch ： 如果项目末设置高度或设置为auto，将占满整个容器的高度 123456789.flex-container &#123; display: -webkit-flex; display: flex; -webkit-align-items: stretch; align-items: stretch; width: 400px; height: 250px; background-color: lightgrey; &#125; 6.align-content : 定义了多根轴线的对齐方式 12345678910111213141516171819如果项目只有一根轴线，该属性不起作用 flex-start:与交叉的起点对齐 flex-end : 与交叉轴的终点对齐 center ： 与交叉轴的中点对齐 space-between : 与交叉两端对齐 space-around : 与交叉轴两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch(默认值) : 轴线占满整个交叉轴 .flex-container &#123; display: -webkit-flex; display: flex; -webkit-flex-wrap: wrap; flex-wrap: wrap; -webkit-align-content: center; align-content: center; width: 300px; height: 300px; background-color: lightgrey; &#125; 五、项目的属性1.order:定义项目的排列顺序，数值越小，排列越靠前，默认为0 1234567891011.flex-item &#123; background-color: cornflowerblue; width: 100px; height: 100px; margin: 10px; &#125; .first &#123; -webkit-order: -1; order: -1; &#125; 2.flex-grow : 定义项目的放大比例，默认为0， 即如果存在剩余空间，也不放大，如果所有的flex-grow属性都为1，则他们将等分剩余空间如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍 3.flex-shrink : 定义了项目的缩小比例默认为1 ，即如果空间不足，该项目将缩小如果所有的项目flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，则其他项目都为1，则空间不足时，前者不缩小，负值对该属性无效 4.flex-basis : 定义了了在分配多余空间之前，项目占据的主轴空间浏览器器根据这个属性，计算主轴是否有多余空间默认值为auto，即项⽬目的本来大小可以设为跟width和height属性一样的值，则项目将占据固定空间 5.flex / flex: flex-grow flex-shrink flex-basis 1234567891011121314151617181920//flex: 1 0 auto;占几份,不让缩小, .flex-item &#123; background-color: cornflowerblue; margin: 10px; &#125; .item1 &#123; -webkit-flex: 2; flex: 2; &#125; .item2 &#123; -webkit-flex: 1; flex: 1; &#125; .item3 &#123; -webkit-flex: 1; flex: 1; &#125; 6.align-self :属性允许单个项目有与其它项目不不一样的对齐方式，可覆盖align-items属性默认值auto 表示继承父元素的align-items属性，如果没有父元素，则等同于stretch该属性有6个值，除了了auto，其它都与align-items属性完全一致 123456789101112131415161718192021222324252627282930.flex-item &#123; background-color: cornflowerblue; width: 60px; min-height: 100px; margin: 10px; &#125; .item1 &#123; -webkit-align-self: flex-start; align-self: flex-start; &#125; .item2 &#123; -webkit-align-self: flex-end; align-self: flex-end; &#125; .item3 &#123; -webkit-align-self: center; align-self: center; &#125; .item4 &#123; -webkit-align-self: baseline; align-self: baseline; &#125; .item5 &#123; -webkit-align-self: stretch; align-self: stretch; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2F2015%2F06%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[一、工厂模式工厂模式：通过工厂函数获取想要的内容 12345678function creatPerson(name) &#123; // 创造出想要的对象 var obj = &#123;&#125;; // 给对象添加必要的数据 obj.name = name; // 把创建好的对象返回出去 return obj; &#125; // 利：简化创造对象的操作，只需要调用函数就可以获取对象// 弊：无法判断出对象的归属 123var obj1 = creatPerson('宁哥'); console.log(obj1 instanceof creatPerson); console.log(obj1 instanceof Object); 二、单例模式单例模式:通过单例创建出来的对象，只初始化(实例化)一次，以后调用创建方法获取到的对象永远是第一次调用所创建出来的对象 123456function CreatePerson(name)&#123; this.name = name; &#125; CreatePerson.prototype.sayHi = function()&#123; console.log("hello"); &#125; 1、不使用闭包，在函数内部调用内部函数这样的做法不合理，因为这样还是可以每次调用这个函数创建出好多不同的对象 12345678910111213141516var person = null;//把这个写成全局中，对代码结构不太好 function SingalPerson()&#123; var person = null; function aaa(name)&#123; if(!person)&#123; person = new CreatePerson(name); &#125; &#125; aaa(name) console.log(person); //这样子return出去后函数里面就没有了person了，又还需要创建 return person; console.log(person); &#125; var a = SingalPerson(); console.log(a); 2、用闭包的方式是person被return出去后不会被销毁，一直存在内存中//单例创造对象的函数 123456789function SingalPerson()&#123; var person = null; return function(name)&#123; if(!person)&#123; person = new CreatePerson(name); &#125; return person; &#125; &#125; 虽然可以只调用一步SingalPerson()；就可以实现单例效果，但是如果两个对象分别是在函数里面创建，就需要在各自的函数里调用两次SingalPerson;当然也可以把调用SingalPerson()的表达式写在全局中，这样每次创建对象都可以来调用存贮SingalPerson()结果的变量，但是这样就把单例操作分成了两部分，对程序的逻辑和结构方面不太好 12345678910var a = SingalPerson(); var obj1 = a("haha"); console.log(obj1); //这样就可以看到单例的效果了 var obj3 = a("lala"); console.log(obj3); //如果执行两次SingalPerson()就会创建两个不同的对象 //var b = SingalPerson(); //var obj2 = b("lala"); //console.log(obj2); 3、使用闭包和立即执行函数实现要把最外面的函数只执行一遍，就可以使用到自调用，这样就不用在外面再去定义执行全局的函数，当程序执行到这行代码时就立刻执行这个函数，再用一个变量来保存这个函数的结果，然后可以在外面就可以调用这个变量了，因为外面的那个函数返回的就是我们不断执行的内部函数 12345678910111213var aa = (function SingalPerson()&#123; var person = null; return function(name)&#123; if(!person)&#123; person = new CreatePerson(name); &#125; return person; &#125; &#125;)(); var obj1 = aa("haha"); console.log(obj1); var obj2 = aa("lala"); console.log(obj2); 三、单例模式的实例 单例模式实现模态窗口 12345678910111213141516171819202122232425var creatDiv = (function()&#123; var div = null; // 向外返回的函数是真正用来创建标签、拼接标签的操作 return function() &#123; // 判断标签是否存在，不存在就创建，存在就直接返回这个标签 if (!div) &#123; div = document.createElement('div'); div.setAttribute('style', 'width: 100px; height:100px; border:1px solid black'); document.body.appendChild(div); &#125; return div; &#125; &#125;)(); // 页面加载完毕后添加点击事件 window.onload = function () &#123; document.getElementById('btn').onclick = function () &#123; var divElement = creatDiv(); divElement.style.display = 'block'; divElement.onclick = function() &#123; document.body.removeChild(divElement); divElement.style.display = 'none'; &#125; &#125; &#125; 四、代理模式代理是一个对象，它可以用来控制对本体对象的访问，它与本体对象实现了同样的接口，代理对象会把所有的调用方法传递给本体对象的；代理模式最基本的形式是对访问进行控制，而本体对象则负责执行所分派的那个对象的函数或者类，简单的来讲本地对象注重的去执行页面上的代码，代理则控制本地对象何时被实例化，何时被使用；我们在上面的单体模式中使用过一些代理模式，就是使用代理模式实现单体模式的实例化，其他的事情就交给本体对象去处理；代理两个优点：1、代理对象可以代替本体被实例化，并使其可以被远程访问；2、它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象第一种方案：不使用代理的预加载图片函数如下 123456789101112131415// 不使用代理的预加载图片函数如下 var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = "http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"; img.src = src; &#125; &#125; &#125;)(); // 调用方式myImage.setSrc(“https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png“);第二种方案：使用代理模式来编写预加载图片的代码如下： 12345678910111213141516171819202122var myImage = (function()&#123; var imgNode = document.createElement("img"); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125; &#125;)(); // 代理模式 var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc("http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif"); img.src = src; &#125; &#125; &#125;)(); // 调用方式ProxyImage.setSrc(“https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png“);第一种方案是使用一般的编码方式实现图片的预加载技术，首先创建imgNode元素，然后调用myImage.setSrc该方法的时候，先给图片一个预加载图片，当图片加载完的时候，再给img元素赋值，第二种方案是使用代理模式来实现的，myImage 函数只负责创建img元素，代理函数ProxyImage 负责给图片设置loading图片，当图片真正加载完后的话，调用myImage中的myImage.setSrc方法设置图片的路径； 他们之间的优缺点如下： 第一种方案一般的方法代码的耦合性太高，一个函数内负责做了几件事情，比如创建img元素，和实现给未加载图片完成之前设置loading加载状态等多项事情，未满足面向对象设计原则中单一职责原则；并且当某个时候不需要代理的时候，需要从myImage 函数内把代码删掉，这样代码耦合性太高。 第二种方案使用代理模式，其中myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可； 从上面代理模式我们可以看到，代理模式和本体对象中有相同的方法setSrc,这样设置的话有如下2个优点： 用户可以放心地请求代理，他们只关心是否能得到想要的结果。假如我门不需要代理对象的话，直接可以换成本体对象调用该方法即可。 在任何使用本体对象的地方都可以替换成使用代理。五、观察者模式：发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 发布订阅模式的优点： 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；发布订阅模式的缺点：创建订阅者需要消耗一定的时间和内存。虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。 首先要想好谁是发布者(比如上面的卖家)。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 我们还可以在回调函数里面添加一点参数 12345678910111213141516var saleHouse = &#123;&#125;;//发布者 saleHouse.clientlist = [];//客户的列表 saleHouse.listen = function(client)&#123;//注册被通知的客户,放入列表中 // this.clientlist.push(client);// console.log(this.clientlist)//[]就是上面的saleHouse.clientlist saleHouse.clientlist.push(client) &#125; saleHouse.trigger = function()&#123;//发通知 for(var i = 0,s;s = this.clientlist[i++];)&#123;//跟我们平时写方法相同 s.apply(this,arguments);//调用函数，有参数的情况下用apply &#125; &#125; saleHouse.listen(function(position,price)&#123; console.log('地点:'+position+"价格:"+price) &#125;) saleHouse.trigger('前海湾','120000') 六、适配器模式 适配器模式：将一个对象或者类的接口翻译成某个指定的系统可以使用的另外一个接口. 适配器基本上允许本来由于接口不兼容而不能一起正常工作的对象或者类能够在一起工作.适配器将对它接口的调用翻译成对原始接口的调用，而实现这样功能的代码通常是最简的。 12345678910111213141516171819var MyRenderMap = function(service) &#123; if(service.show instanceof Function)&#123; service.show(); &#125; &#125; // MyRenderMap(baiduMap) // MyRenderMap(gooleMap) //如果方法名不同的话就要用到适配器 var gooleMap = &#123; abc:function()&#123; console.log('谷歌为你服务！') &#125; &#125; var gooleMapAdapter=&#123; show:functioun()&#123; return gooleMap.abc()//可能有些适配器需要返回 &#125; &#125; MyRenderMap(gooleMapAdapter) 上面的适配器也是每个不同的对象都要一个适配器（面版模式)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RequireJs]]></title>
      <url>%2F2015%2F05%2F08%2Frequirejs%2F</url>
      <content type="text"><![CDATA[一、传统代码的缺陷传统的用script标签导入的JS文件，有可能会阻塞页面渲染，而且正常我们开发的时候会导入引入JS文件，都用script标签导入，很容易造成混乱，不容易维护 二、什么是模块化模块在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。随着网页越来越复杂，网页中引入的JS文件也就越来越多，单纯的用引入js文件，已经满足不了我们的需求，我们需要团队协作，模块分离模块化是指在处理某些问题时，按照一种分类或者思想对功能进行模块化管理和使用 使用模块有什么好处？最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 三、模块化编程规范NodeJS实现了JavaScript语言编写后台，其中使用CommonJS规范实现了模块化开发模块化开发其实就是让JavaScript文件可以互相引用，每个文档代表一个模块，提高代码的使用频率。在HTML中引入JS文件也会方便很多。原生JavaScript中并不支持模块化开发，出现了一些规范，就是所说的AMD和CMD，这两种方式适合使用桌面端，可以进行异步加载，而在NodeJS中使用CommonJS是同步的，所以CommonJS并不适合桌面端 在require.js推广的过程中，产生了一种模块化规范，叫AMD 在sea.js推广的过程中，产生了一种模块化规范，叫CMD sea.js是淘宝的前端开发工程师，网名叫玉伯的人编写的。require.js而是国外朋友编写。sea.js是根据CommonJS规范来编写的，和CommonJS语法类似，而require.js的写法则教特殊一些四、requirejs能带来什么好处?看下面的示例:正常编写方式 12345678910// index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 1234567&lt;!--a.js:--&gt;function fun1()&#123; alert("it works");&#125;fun1(); 可能你更喜欢这样写 1234567(function()&#123; function fun1()&#123; alert("it works"); &#125; fun1();&#125;)() 第二种方法使用了块作用域来申明function防止污染全局变量，本质还是一样的，当运行上面两种例子时不知道你是否注意到，alert执行的时候，html内容是一片空白的，即body并未被显示，当点击确定后，才出现，这就是JS阻塞浏览器渲染导致的结果。requirejs写法当然首先要到requirejs的网站去下载js 1234567891011121314&lt;!--index.html:--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="require.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; require(["a"]); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;body&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 123456789&lt;!--a.js:--&gt;define(function()&#123; function fun1()&#123; alert("it works"); &#125; fun1();&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GulpJs]]></title>
      <url>%2F2015%2F02%2F11%2Fgulpjs%2F</url>
      <content type="text"><![CDATA[一、安装gulp1.先在全局环境下安装gulp 1$ npm install --global gulp 2.生成json文件，初始化 3.作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 1234567// 导入gulp模块var gulp = require('gulp');// 创建一个任务，名字是default的话就是默认的任务，在终端使用gulp就会直接执行这个任务gulp.task('default', function() &#123; // 将你的默认的任务代码放在这 console.log("这是一个默认任务！！！")&#125;); 运行 gulp： 1$ gulp 1234567891011121314151617181920// 导入gulp模块var gulp = require(&apos;gulp&apos;);// 创建一个任务，名字是default的话就是默认的任务，在终端使用gulp就会直接执行这个任务gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这，默认的就可以直接gulp console.log(&quot;这是一个默认任务！！！&quot;)&#125;);// 如果要执行额外的功能，就在终端输入gulp sayHellogulp.task(&quot;sayHello&quot;,function()&#123; console.log(&quot;hello world!!!&quot;)&#125;)```bash![image](http://a2.qpic.cn/psb?/V11mx6TD0YZt7E/Fejejzzd40pizUgvD1gzsBGXvxOCagMOAairVYULPVc!/b/dG8BAAAAAAAA&amp;bo=oAFeAAAAAAADANo!&amp;rf=viewer_4)二、gulp的一些API```bashgulp的API中文链接http://www.gulpjs.com.cn/docs/api/http://gulpjs.com/plugins/ 1、拷贝任务 123456789//拷贝任务gulp.task("copy",function()&#123; //先获取要拷贝的文件 gulp.src("./src/*.html") //通过管道进行下一步操作，是一个链式语法 //desc方法是输出文件到什么位置 .pipe(htmlmin(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest("./dist/"));&#125;) 如果想要在改变文件的内容，拷贝后的文件也会自动改变就要设置监听 1234567//监听任务gulp.task("dist",function()&#123; // 利用watch方法进行监听 // 第一个参数是监听哪个文件是否被改变 // 如果改变了就执行第二个参数里面的任务 gulp.watch("./src/*.html",["copy","sayHello"]);&#125;) 2、less转换css 1234567891011var less = require('gulp-less');// var path = require('path');gulp.task('less', function () &#123; return gulp.src('./src/styles/*.less') .pipe(less( // &#123; // paths: [ path.join(__dirname, 'less', 'includes') ] // &#125; )) .pipe(gulp.dest('./dist/css'));&#125;); 如果想要不断写less文件，css文件也会改变 12345//监听任务gulp.task("dist",function()&#123; //监听less文件的状态 gulp.watch("./src/styles/*.less",["minify"]);&#125;) 3、压缩文件 12345678var gulp = require('gulp');var htmlmin = require('gulp-htmlmin'); gulp.task('minify', function() &#123; return gulp.src('src/*.html') .pipe(htmlmin(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest('dist'));&#125;); 也可以设置监听，自动压缩 12345//监听任务gulp.task("dist",function()&#123; //监听less文件的状态 gulp.watch("./src/styles/*.less",["less"]);&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>%2F2014%2F09%2F08%2F%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[一、优化字面量的方法12345678910111213var obj1 = &#123; name:'张三', age:24 &#125;; var animal=&#123; name:'翠花', age:3 &#125;; function CreatePerson(name,age)&#123; this.name = name; this.age = age; &#125; var obj2 = new CreatePerson('李四',28) obj1和animal的constructor都是指向object，而obj2的constructor是指向CreatePerson的构造函数的，因为是构造函数所创建的实例 123456console.log(obj1.constructor) console.log(animal.constructor) console.log(obj2.constructor); 优化字面量 function Box()&#123;&#125; 改变原型里面的属性，覆盖了本身的prototype，就没有了constructor 1234567891011Box.prototype = &#123; constructor:Box, name:'jj', age:22 &#125; var person = new Box(); console.log(person) //undefined因为对象里面的prototype不能访问 console.log(person.prototype) console.log(Box.prototype) console.log(person.constructor) 二、原型什么是原型？原被型是当构造函数被调由系统用时创把建出来的一个实例，我们可以利用原型这个实例把对象中相同的属性和方法添加到原型中，达到节约内存的目的。如何获取到原型？在构造函数中有一个“prototype”的属性，该属性就指向了构造函数的原型，函数名.prototypeprototype属性：通过这个属性能获取到对应的原型. 1234567891011121314function CreatePreson(name,age,gender)&#123; this.name = name; this.age = age; CreatePreson.prototype.gender = gender; CreatePreson.prototype.sayBye = function()&#123; console.log('bye') &#125; &#125;; //通过函数名下的prototype属性获取函数原型 CreatePreson.prototype.sayHi = function()&#123; console.log('hi') &#125; //创建对象，并调用原型方法 var per1 = new CreatePreson('jio',22,'man') 因为该方法并不是实例方法,所以实例调用这个方式时，在实例中找不到，就再进入实例的原型中寻找，找到就执行。对象如何获取它的原型:每个对象都有一个proto属性，该属性就指向了对象对应的原型，但是该属性我们 无法访问。 1234567console.log(per1.__proto__) console.log(CreatePreson.__proto__) per1.sayHi(); per1.sayBye(); console.log(per1.gender) //constructor :原型下的属性，可以通过该属性获取到原型对应的构造函数 console.log(CreatePreson.prototype.constructor) 三、通过构造函数创建对象方法的二次优化把拥有相同值的属性，方法添加到原型中，把不同的属性和方法添加到各自的对象中 123456789function CreateAnimal(name,age)&#123; //因为动物的名字和年龄各不相同，所以把这两个属性添加到对象中 this.name = name; this.age = age; //因为动物都有吃东西的方法，所以可以放到原型中 CreateAnimal.prototype.eat = function()&#123; console.log('吃东西') &#125; &#125; 四、通过构造函数创建对象方法的三次优化1234567891011121314function CreatePerson(name,age)&#123; this.name = name; this.age = age; //每次调用都会在在原型里面创建一次，很累赘。所以用if来判断，如果原型里面 //有该方法，就不用再往原型里面放了因为每个对象的方法都是相同，所以我们可 //以把相同的方法添加到原型里传统添加方式：每次调用都会给原型添加一次方法 //优化方法：判断原型中是否已经存在要添加的方法，如果没有就添加，否则不添加。 if(typeof(CreatePerson.prototype.sayHi) != 'function')&#123; console.log('我被执行了') CreatePerson.prototype.sayHi = function()&#123; console.log('hello'+this.name) &#125; &#125; &#125; 写在外面不太合理的原因，是因为程序由上到下执行，对象还没有调用，就已经把方法添加到了原型中，有可能用不到方法 1234567CreatePerson.prototype.sayHi = function()&#123; console.log('hello') &#125; var per1 = new CreatePerson('李四',22) per1.sayHi(); var per2 = new CreatePerson('向三',11) per2.sayHi(); 五、原型操作定义一个是构造函数，有一个实例属性：name，有一个原型属性age 123456789101112131415161718192021222324252627function CreatePerson(name,age)&#123; this.name = name; CreatePerson.prototype.age=age; &#125; //调用构造函数创建对象 var per1 = new CreatePerson('jio',22); console.log(per1); console.log(per1.age) var per2 = new CreatePerson('margi',18); //原型修改会被提升，所以上面打印就是console.log(per1)的__proto__中就可以看到. console.log(per1); console.log(per2); console.log(per1.age) //定义一个是构造函数，有一个实例属性：name，有一个原型属性age function CreatePerson (name) &#123; this.name = name; CreatePerson.prototype.age = 18; &#125; //调用构造函数创建对象 var per1 = new CreatePerson('宁哥'); var per2 = new CreatePerson('凯哥'); //in操作符，只能判断对象中有没有该属性，无法判断属性是实例属性还是原型属性 console.log('name' in per1);//true console.log('age' in per1);//true //hasOwnProperty方法：判断属性是否是对象的实例属性，是则返回true，不是或没有该属性，返回false。 console.log(per1.hasOwnProperty('name'));//true console.log(per1.hasOwnProperty('age'));//false 判断属性是否是原型属性 1234567891011121314151617181、判断指定的字符串是对象下的属性 if ('age' in per1) &#123; 2、判断属性是否是原型属性:对hasOwnProperty取反 if (!per1.hasOwnProperty('age')) &#123; console.log('原型属性'); &#125; &#125; 简化操作 if ('age' in per1 &amp;&amp; !per1.hasOwnProperty('age')) &#123; console.log('原型属性'); &#125; 深度简化 CreatePerson.prototype.hello = function hello (proto) &#123; if (proto in this &amp;&amp; !this.hasOwnProperty(proto)) &#123; console.log('原型属性'); &#125; &#125;; per1.hello('age'); 六、call和apply12345678910111213141516function sayHi(name1,name2)&#123; console.log(name1+' '+name2+' hahah'); console.log(this) console.log(name) &#125; sayHi(); sayHi.call();//call方法就是用来调用函数的 //第一个参数是可以改变this的指向， //sayHi.call(Object); //sayHi.call(Array); //第二个参数是函数需要的参数 //sayHi.call(Object); //sayHi.call(Array,'jj'); sayHi.call(null,'jj','hh');//指向window //apply第二个参数必须是数组类型的 sayHi.apply(Array,['jj','hh']) 总结 我们既可以使用”()”来调用函数，也可以使用call方法来调用函数 使用call调用执行函数，该方法需要有两大类的参数 第一大类参数是：用来修改要执行的函数中的this指针的指向 第二大类参数是：要执行函数所需要的参数 七、call和apply的继承创建出第一个函数（父函数\父类） 1234567function CreateAnimal (name, age) &#123; this.name = name; this.age = age; this.sayHi = function () &#123; alert('hello'); &#125; &#125; 创建第二个函数：这个函数获取到的对象也有第一个函数中的属性和方法，我们可以将这些相同的属性和方法从第一个函数中获取到，这样第二个函数就不必单独再写一次赋值操作。 因为第二个函数从第一个函数中拿到了全部属性、方法则我们认为第二个函数是第一个函数的子类。 通过call 方法实现继承：修改第一个函数中this的指向，改为person对象，这样在执行第一个函数时，就给person对象添加了属性和方法 12345678function CreatePerson (name, age) &#123; 利用call调用执行第一个函数，并修改他的指针指向为person CreateAnimal.call(this, name, age); 添加本函数独有的属性和方法 this.sayBye = function()&#123; alert('bye-bye'); &#125; &#125; 八、原型继承父函数 1234567function CreateAnimal (name,age) &#123; this.name = name; this.age = age; this.sayHi = function () &#123; alert('hello'); &#125;; &#125; 子函数 123456function CreatePerson (gender) &#123; this.gender = gender; this.sayBye = function() &#123; alert('bye'); &#125;; &#125; 1、创建一个父类的对象，把这个对象当做子类的原型 1CreatePerson.prototype = new CreateAnimal('宁哥', 24); 2、因为此时子类原型中的constructor指向的是父类构造函数，所以创建出的对象也 将指向Animal这个函数。为了让constructor的指向正确，需要修改Person原型中的constructor 1CreatePerson.prototype.constructor = CreatePerson; 3、创建并使用子类对象 1234var per = new CreatePerson('男'); console.log(per.name); console.log(per.age); console.log(per.gender); 九、组合继承父类函数:属性保存在实例中，方法保存在原型中 1234567function CreateAnimal(name,age)&#123; this.name = name; this.age = age; CreateAnimal.prototype.sayHi = function()&#123; console.log('hello'); &#125; &#125; 子类函数:通过call继承实例相关 12345678function CreatePerson(name,age,gender)&#123; //使用call从父类继承属性和方法只是this的指向的问题，把父类中的this强变成子类中的this，也就是子类的对象，而sayHi方法不是在this上，而是在原型上 CreateAnimal.apply(this,arguments) this.gender = gender; CreateAnimal.prototype.sayBye = function()&#123; console.log('bye'); &#125; &#125; 因为父类有添加在原型中方法，通过call获取不到，所以需要使用原型来获取这些方法因为只是想获取到父类的原型方法，所以不需要给父类的属性传参 12345678CreatePerson.prototype = new CreateAnimal(); 把子类的constructor属性改回来 CreatePerson.prototype.constructor = CreatePerson var person= new CreatePerson('jj',22,'man'); console.log(person.name) console.log(person.age) console.log(person.gender) person.sayHi();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[border-radius边框详解]]></title>
      <url>%2F2014%2F01%2F08%2Fborder-radius%E8%BE%B9%E6%A1%86%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[传统的圆角生成方案，必须使用多张图片作为背景图案。CSS3的出现，使得我们再也不必浪费时间去制作这些图片了，只需要border-radius属性，支持浏览器IE 9、Opera 10.5、Safari 5、Chrome 4和Firefox 4 一、border-radius属性 CSS3圆角只需设置一个属性：border-radius（含义是”边框半径”）。你为这个属性提供一个值，就能同时设置四个圆角的半径。所有合法的CSS度量值都可以使用：em、px、百分比等等。比如,下面是一个div方框（宽高都是200，背景为红色，边框为2px solid #000） 现在设置它的圆角半径为50px,即： 1border-radius:50px; 这条语句同时将每个圆角的”水平半径”和”垂直半径”都设置为50px border-radius可以同时设置1到4个值。（想想我们之前的margin与padding）如果设置1个值，表示4个圆角都使用这个值。如果设置两个值，表示左上角和右下角使用第一个值，右上角和左下角使用第二个值。如果设置三个值，表示左上角使用第一个值，右上角和左下角使用第二个值，右下角使用第三个值。如果设置四个值，则依次对应左上角、右上角、右下角、左下角（顺时针顺序）。例如： 12border-radius:50px 25px; //表示左上角和右下角使用第一个值，右上角和左下角使用第二个值 border-radius:25px 10px 50px; //左上角使用第一个值，右上角和左下角使用第二个值，右下角使用第三个值 border-radius还可以用斜杠设置第二组值。这时，第一组值表示水平半径，第二组值表示垂直半径。第二组值也可以同时设置1到4个值，应用规则与第一组值相同。 1border-radius:50px/25px; 1border-radius: 100px 25px 80px 5px / 45px 25px 30px 15px; 二、单个圆角的设置 除了同时设置四个圆角以外，还可以单独对每个角进行设置。对应四个角，CSS3提供四个单独的属性： 1234567* border-top-left-radius * border-top-right-radius * border-bottom-right-radius * border-bottom-left-radius 这四个属性都可以同时设置1到2个值。如果设置1个值，表示水平半径与垂直半径相等。如果设置2个值，第一个值表示水平半径，第二个值表示垂直半径。1border-top-left-radius: 50px; 12border-top-left-radius: 50px 100px;//第一个值表示水平半径，第二个值表示垂直半径。 三、效果 123456789width:0; height:0;border:100px solid gray;border-radius:100px;border-right-color:#fff; 1234567height:100px;width:200px;background: red;border-radius:100px/50px;]]></content>
    </entry>

    
  
  
</search>
